Java实现生产者和消费者的三种方法 
答：synchronized、lock、BlockingDeque（阻塞式双向队列）
代码实现逻辑：创建一个生产者和消费者模型，一（synchronized），对生产者和消费者的方法加入synchronize，在生产完成后唤醒消费者线程，在消费完成后唤醒生产者线程（notifyAll()）。二（Lock），对生产者和消费者进行加锁，用try{}finally{}块保证锁的使用，在finally中调用解锁的方法。三（BlockingDeque），这是在存储内部保证了线程的安全，底层其实也是锁的机制。
init方法与clinit方法的区别 
<clinit>：在jvm第一次加载class文件时调用，包括静态变量初始化语句和静态块的执行
<init>:在实例创建出来的时候调用，包括调用new操作符；调用Class或java.lang.reflect.Constructor对象的newInstance()方法；调用任何现有对象的clone()方法；通过java.io.ObjectInputStream类的getObject()方法反序列化。
（1）<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块只能访问到定义在静态语句块之前的变量，点贵在他之后的变量，在前面的静态语句块中可以赋值但不能访问。
（2）<clinit>()方法与类的构造函数（或者说实例构造器中的<init>()方法）不同， 它不需要显示的调用父类构造器，虚拟机会保证在子类的<init>()方法执行之前，父类的<clinit>()方法已经执行完毕。因为在虚拟机中第一个被执行的<clinit>()方法的类肯定是java.lang.Object。
（3）由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类类的变量赋值操作。
（4）<clinit>()方法对于类或者接口来说并不是必须的，如果一个类没有静态语句块，也就没有变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法。
（5）接口中不能使用静态语句块，但仍然可以有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法。但接口与类不同，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。
（6）虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只有一个线程去执行这个类的<clinit>()方法中有耗时很长的操作，就可能造成多个线程阻塞。
Java中的引用 
答：Java中有8个常量，即char,short,byte,int,float,long,double,boolean，这些常量的创建就是直接放在栈中，程序进入时创建，程序结束时值就消失，Java中String，数组等这些就是引用，创建时，在栈中存放变量名和值在堆中的地址，String在堆中存在两个，一个是包含它的值真实地址和长度的变量，一个是值的变量。
Java对象的创建过程 
类加载检查-->分配内存-->初始化零值-->设置对象头-->执行init方法
1、类加载检查：虚拟机遇到一条new指令时，先检查这个指令的参数能否在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，则先进行类的加载过程。
2、分配内存：有两种方式
指针碰撞：假设Java堆中的内存是规整的，用过的内存在一边，空闲的在另一边，中间有一个指针作为分界点的指示器，所分配的内存就把那个指针向空闲那边挪动一段与对象大小相等的距离。
空闲列表：如果Java堆中的内存不是规整的，虚拟机必须维护一个列表，记录哪些内存块可用的，分配时从列表中找到一块足够大的空间划分给对象，并更新列表的记录。
在划分可用空间时，会遇到线程安全的问题。解决这个问题有两种方案。第一种：对分配内存空间的动作进行同步处理--虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。另一种是把内存分配的动作安装现场划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB）。那个线程需要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。是否使用TLAB，-XX：+UseTLAB参数来设定。
3、初始化零值 将分配到的内存空间都初始化为零值，如果用TLAB，则在TLAB分配时初始化为零值。
4、设置对象头：主要设置类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。
5、执行init方法初始化。
Java中创建子类实例时会创建父类实例？ 
Java的类加载机制 为什么会出现锁机制？
  
抽象类和接口的区别 
答：抽象类中方法体可以实现过程，而接口中是不能实现方法的，抽象类中是可以定义变量的，接口是不能定义变量的
（1）抽象类可以有构造方法，接口中不能有构造方法。
（2）抽象类中可以有普通成员变量，接口中没有普通成员变量
（3）抽象类中可以包含静态方法，接口中不能包含静态方法
（4） 一个类可以实现多个接口，但只能继承一个抽象类。
（5）接口可以被多重实现，抽象类只能被单一继承
（6）如果抽象类实现接口，则可以把接口中方法映射到抽象类中作为抽象方法而不必实现，而在抽象类的子类中实现接口中方法
重载与重写 
Java的类型擦除 
答：就是泛型在编译后都会被去掉，例如说List<String>,在编译后JVM中只看到List，而String被去掉了。从中带来一些问题，Java是如何保证的呢：编译时就会去检查，比如说List<String>中，实际上泛型String已经被去掉，变成了类似于Object，但是在调用add()方法时，只能加入”123”,而在加入123就会编译报错
简述Java Object类中的方法有哪些 
答：equals(),wait(),notify(),notifyAll(),
1 registerNatives()   //私有方法
 2 getClass()    //返回此 Object 的运行类。
 3 hashCode()    //用于获取对象的哈希值。
 4 equals(Object obj)     //用于确认两个对象是否“相同”。
 5 clone()    //创建并返回此对象的一个副本。 
 6 toString()   //返回该对象的字符串表示。   
 7 notify()    //唤醒在此对象监视器上等待的单个线程。   
 8 notifyAll()     //唤醒在此对象监视器上等待的所有线程。   
 9 wait(long timeout)    //在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或        者超过指定的时间量前，导致当前线程等待。   
10 wait(long timeout, int nanos)    //在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量前，导致当前线程等待。
11 wait()    //用于让当前线程失去操作权限，当前线程进入等待序列
12 finalize()    //当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。
equals()的重写规则
答：equals()的重写规则，最主要是重写里面的逻辑，而重写的要求是一定要重写hashCode方法。
自反性原则：即a.equals(a);
对称性:a.equals(b)那么b.equals(a)都为true
传递性:即子类继承的父类这两个用equals的时候也要返回true
char可以存储汉字嘛？
 答：可以，因为char是两个字节的
静态分派与动态分派 
答：这是一种多态的展现，静态分派是指在编译期间就确定的方法或者变量，比如说是静态方法和私有方法，这些都是不能继承和重写的，而动态分派就是可以指定是调用父类还是子类的方法的
简述Java中的深拷贝与浅拷贝，C++中的浅拷贝和深拷贝 
解释一下static块和static变量的执行顺序 
变量名首先被加载，而赋值的时候，无论是直接在变量上赋值还是在静态代码块中赋值，都是按照代码的顺序赋值的
Java中如何创建线程？ 
答：3种方式：实现Runnable接口，继承Thread()类，实现Callable()接口
JDK1.8新特性 
线程池 什么时候到达最大线程数 到达最大线程后继续提交的表现
答：ThreadPoolExecutor，创建线程池的时候，会指定其核心线程的数量和临时线程的数量还有等待的队列大小，每一个请求过来都会去新建一个新的核心线程数量，当到达最大核心线程数量后再有新的请求就会放在队列中等待，而队列也满了的时候，再来请求就会用临时线程去接收这个请求，而临时线程并不是使用后就马上杀掉，而是会存活一段时间，而在队列中等待的请求只会用核心线程去处理。
创建时的队列可以有下面几种
ArrayBlockingQueue;基于数组的阻塞式队列创建时需要指定容量
LinkedBlockingQueue;链表形式的阻塞式队列，可以不用指定容量，默认是Integer.MAX_VALUE
SynchronousQueue;同步队列，不需要指定容量，容量为1


JVM： 
JVM内存布局 
JVM垃圾回收机制 
JVM垃圾回收算法 
哪些对象在老年代？ 
从年轻代到老年代执行的时间以及发生转移的场景 
为什么存在GC？ 
简单可达性分析 
Minor GC安全检查 
垃圾回收器 
引用记数法和可达性算法 
类加载机制过程 
双亲委派模型 
双亲委派机制 
双亲委派模型：启动加载器、扩展加载器、应用程序加载器 
答：双亲委派模型首先要理解Java的类加载，而双亲委派模型就是在类加载器需要加载类的时候需要去将这个请求委派给父类的加载器，依次递归到最顶级的类加载，双亲好处就是保护系统中不会存在多个相同的名称的类出现混乱，保护核心的基础类型的代码，这其中也有特例：比如说是JDBC这种，Java的类加载器就只能让其子类加载。
Java散列表，树对应的容器类，hashmap如何解决冲突 
答：散列表：hashMap,hashTable,concurrentHashmap,树：hashSet,treeSet,treeMap.
 HashMap如何解决冲突
1.开放定址法： 通过探测算法，当一个槽位已经被占用情况下继续查找下一个
2.链地址法（数组+链表）
3.再哈希 准备多个散列函数，当发生冲突时，再选择一个散列函数进行散列。
什么时候使用HashMap？它有什么特点？ 
HashMap的基本原理及内部数据结构 
HashMap的put和get操作 
锁分段技术、ConcurrentHashMap、扩容
concurrentHashMap:本质上也是一个map，并发及线程安全的映射，初始容量16，扩展因子是0.75，jdk1.8之后，容量大于8的时候就从链表结构转成了红黑树，小于7的时候又转化成数组+链表的结构，concurrentHashMap一开始采用了分段锁机制来保证并发安全，后来采用了读写锁机制，1.8开始加入了CAS算法机制（CAS算法就是如果A去修改一个V的值得时候，B也在修改，那么他会去看这个值A预期值是多少，如果已经是预期值了，说明已经修改，只需要将这个值得预期值告诉V，如果在修改的时候，这个值被修改了，那么A会重新去拿V的值来比对）；
什么是红黑树呢：红黑树本质上是一个二叉自平衡的树，它有几个特点，就是节点非黑即红，根节点必须是黑，红节点下必须是黑，最后都是一个黑的子节点，根节点到每一个最终子节点的经过的路径数量都是一样多的，新添加的节点都必须是红的。
红黑树的修正：是一个链式过程，如果子节点和父节点都是红的即需要修正它；叔父节点和父节点都为红，则把父节点和叔父节点都变成黑的同时把祖父节点涂黑，如果子节点是右子节点，则以当前节点左旋。然后叔父节点为黑，则以当前节点的父节点右旋。
HashMap与HashTable的区别 
答：HashMap和HashTable最主要的区别就是一个是线程安全的而HashMap不是线程安全的，因此HashMap在效率上比HashTable要高，一般情况下，在不考虑线程安全的时候可以使用HashMap，它在使用上有比较高的效率。HashMap是由数组+链表的结构组成，默认容量是16，扩展因子是0.75，每次扩容是一倍。在容量大于8 的时候现在的结构就会转化成红黑树结构。
 

Hashmap是线程安全的吗?为什么？
HashMap在put的时候，插入的元素超过了容量（由负载因子决定）的范围就会触发扩容操作，就是rehash，这个会重新将原数组的内容重新hash到新的扩容数组中，在多线程的环境下，存在同时其他的元素也在进行put操作，如果hash值相同，可能出现同时在同一数组下用链表表示，造成闭环，导致在get时会出现死循环，所以HashMap是线程不安全的 
ArrayList与LinkedList区别 
答：ArrayList底层是数组结构的，而LinkedList底层是基于链表的结构的，在使用上ArrayList能有更快的查询效率，而增删的时候就要去重新计算位置，效率不高，而LinkedList具有更高的增删效率，因为增删的时候只需要将元素添加到末尾或者删除元素的位置，不影响链表的结构，查询的时候效率较低，是因为查询的时候需要去遍历整个链表。
HashMap、LinkedHashMap和TreeMap 
JDK7与JDK8中hashmap的区别 
hashmap的初始容量为什么设置为16？ 
答：最主要是为了提高效率，我们设置初始化容量时，实际上HashMap会采用该值的2的冥次方，而这种方式能提高查询效率和降低散列时的碰撞几率。
平衡二叉树的插入删除操作 
排序算法比较 
冒泡排序的优化以及快排过程及优化 
并发编程： 
Java同步线程有哪些方式？ 
volatile 和 synchronized的区别 
讲一下同步异步（进程和IO） 
synchronized和volatile的区别？ 
线程安全 
对象的内存布局 
哪些是线程安全的容器？ 
线程启动start和run 
简述Java内存模型的happen before原则 
volatile的原理和实现机制 || volatile到底如何保证可见性和禁止指令重排序的？ 
volatile关键字的两层语义 || 可见性 
volatile保证原子性吗？ 
volatile能保证有序性吗？ 
分布式事务（经常被问到）
1、两阶段提交（2PC）
第一阶段：事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交.
第二阶段：事务协调器要求每个数据库提交数据。
优点： 尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。（其实也不能100%保证强一致）
缺点： 实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景，如果分布式系统跨接口调用，目前 .NET 界还没有实现方案。
2、补偿事务（TCC）
针对每个操作，都要注册一个与其对应的确认和补偿（撤销）。Try、Confirm、Cancel
优点： 跟2PC比起来，实现以及流程相对简单了一些，但数据的一致性比2PC也要差一些
缺点： 缺点还是比较明显的，在2,3步中都有可能失败。TCC属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用TCC不太好定义及处理。
3、本地消息表（异步确保）
核心思想是将分布式事务拆分成本地事务进行处理，消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。
优点： 一种非常经典的实现，避免了分布式事务，实现了最终一致性。在 .NET中 有现成的解决方案。
缺点： 消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。
4、MQ事务消息
RocketMQ支持，RabbitMQ 和 Kafka 都不支持，一次发送消息和一次确认消息，生产方需要实现一个check接口（确认消息或者回滚）
优点： 实现了最终一致性，不需要依赖本地数据库事务。
缺点： 实现难度大，主流MQ不支持，没有.NET客户端，RocketMQ事务消息部分代码也未开源。
5、Sagas事务模型
长时间运行的事务，该模型其核心思想就是拆分分布式系统中的长事务为多个短事务，或者叫多个本地事务，然后由 Sagas
工作流引擎负责协调，如果整个流程正常结束，那么就算是业务成功完成，如果在这过程中实现失败，那么Sagas工作流引擎就会以相反的顺序调用补偿操作，重新进行业务回滚
